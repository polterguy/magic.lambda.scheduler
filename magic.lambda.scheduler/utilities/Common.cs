/*
 * Magic, Copyright(c) Thomas Hansen 2019, thomas@gaiasoul.com, all rights reserved.
 * See the enclosed LICENSE file for details.
 */

using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using magic.node.extensions.hyperlambda;
using magic.node;

namespace magic.lambda.scheduler.utilities
{
    /// <summary>
    /// Common class, that helps initialize scheduler, and contains some helper methods.
    /// </summary>
    public static class Common
    {
        // List of tasks.
        static readonly Synchronizer<List<Task>> _tasks = new Synchronizer<List<Task>>(new List<Task>());
        static readonly object _initLocker = new object();
        static IServiceProvider _provider;

        /// <summary>
        /// Returns your task declaration file, where all tasks are declared as Hyperlambda.
        /// </summary>
        public static string TasksFile { get; private set; }

        /// <summary>
        /// Invoke with the filepath you intend to use for your Hyperlambda tasks file.
        /// </summary>
        /// <param name="tasksFile">The filepath for your scheduled tasks file.</param>
        public static void Initialize(IServiceProvider provider, string tasksFile)
        {
            lock (_initLocker)
            {
                // Sanity checking invocation, to prevent double initialization
                if (TasksFile != null)
                    return;

                // Normalizing filepath.
                tasksFile = tasksFile.Replace("\\", "/").Replace("//", "/");

                if (!tasksFile.EndsWith(".hl"))
                    throw new ArgumentException($"Task filepath must be a Hyperlambda file, your filename ended with '{Path.GetExtension(tasksFile)}'");

                // Ensuring tasks Hyperlambda file exists in root folder, and if not, creating a default file.
                if (!File.Exists(tasksFile))
                {
                    // Creating a default empty task file.
                    using (var stream = File.CreateText(tasksFile))
                    {
                        stream.Write(@"/*
 * You have no tasks.
 * When you do, they can be found in this file.
 *
 * WARNING!
 * DO NOT EDIT THIS FILE MANUALLY UNLESS YOU KNOW WHAT YOU ARE DOING!
 */
");
                    }
                }
                else
                {
                    // Loading existing task file, and populating shared tasks object.
                    using (var stream = File.OpenRead(tasksFile))
                    {
                        var lambda = new Parser(stream).Lambda();

                        // Acquiring write-lock on shared tasks instance.
                        _tasks.Write(tasks =>
                        {
                            foreach (var idx in lambda.Children)
                            {
                                var idxTask = Task.CreateEx(provider, idx);
                                if (idxTask != null)
                                    tasks.Add(idxTask);
                            }
                        });
                    }
                }

                // Setting properties for tasks scheduler.
                TasksFile = tasksFile;

                // Storing service provider, to make sure we can resolve ISignaler as we execute tasks.
                _provider = provider;
            }
        }

        #region [ -- Private and internal helper methods -- ]

        /*
         * Internal helper method that actually adds the task to the task list manager.
         */
        internal static void AddTask(Node taskNode)
        {
            // Synchronizing access to scheduled tasks.
            _tasks.Write(tasks =>
            {
                // Creating a new task.
                var task = Task.Create(_provider, taskNode);
                if (task == null)
                    throw new ApplicationException($"Task's configuration was not acceptible.");

                // Making sure we delete any old task with the same name.
                var current = tasks.FirstOrDefault(x => x.Name == task.Name);
                if (current != null)
                {
                    // Task with specified name already exists, stopping and removing old task before we add new.
                    current.Stop();
                    tasks.Remove(current);
                }

                // Adding task to global shared task list.
                tasks.Add(task);

                // Serializing all tasks to tasks file.
                SerializeTasksToDisc(tasks);
            });
        }

        /*
         * Internal helper method to retrieve task with specified name.
         */
        internal static Node GetTask(string name)
        {
            return _tasks.Read(tasks =>
            {
                return tasks.FirstOrDefault(x => x.Name == name)?.Node.Clone();
            });
        }

        /*
         * Deletes a task from the scheduler.
         */
        internal static void DeleteTask(string taskName)
        {
            _tasks.Write(tasks =>
            {
                // Removing task from shared task list.
                var task = tasks.FirstOrDefault(x => x.Name == taskName);
                if (task == null)
                    throw new ArgumentException($"Task with the name of {taskName} was not found");

                // Deleting task, but first making sure we stop it.
                task.Stop();
                tasks.Remove(task);

                // Serializing all tasks to tasks file.
                SerializeTasksToDisc(tasks);
            });
        }

        /*
         * Returns all tasks in the system.
         */
        internal static IEnumerable<Node> GetTasks()
        {
            return _tasks.Read(tasks =>
            {
                return tasks.Select(x => x.Node.Clone()).ToList();
            });
        }

        /*
         * Saves all tasks to Hyperlambda task file.
         */
        static void SerializeTasksToDisc(List<Task> tasks)
        {
            // Sanity chacking state.
            if (string.IsNullOrEmpty(TasksFile))
                throw new ApplicationException("You have not initialized scheduler, please invoke Common.Init() before you use it");

            // Serializing tasks as Hyperlambda to tasks file.
            var hl = Generator.GetHyper(tasks.Select(x => x.Node));
            using (var writer = File.CreateText(TasksFile))
            {
                writer.Write(hl);
            }
        }

        #endregion
    }
}
